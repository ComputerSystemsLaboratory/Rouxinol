#if 0
????????????????§£????????????????????????????????????????????????AOJ????????????????????????????????????wrong???answer?????????????????????
????????§?????????????????\????????????????????£??????????????§??????????????????????????????????????¨???????????????
???????????????????????? Union Find Tree ???????????????????????????????????????????????????????????????????????????Root?????¢?????°??????????????¨??§??????
??????????????§???????????????????????????????????????????????¢??°???????????¢??°?????????????????£??????????????°???????????°???????\???????????????¨???????????¨???
????????????????????????
Minimum Spanning Tree ???????????§???????????¶??????????????????????????¨????????????????????¨?????????????????????????????????????????????????????£?????????
???????????????????????????????????????
#endif

#include <iostream>
#include<algorithm>
using namespace std;


struct edge
{
   int cost;
   int src;
   int dst;
};

edge e[5001];
int A[101][101];
int M=0;
int P[101];

void init(int N)
{
  for (int i=0; i<=N; ++i) P[i] = i;
}

int root(int a)
{
  if (P[a] == a) return a;
  return (P[a] = root(P[a]));
}

bool is_same_set(int a, int b)
{
  return root(a) == root(b);
}

void unite(int a, int b)
{
  P[root(a)] = root(b);
}

void checkEdges(int n)
{
    for(int r=0;r<n;r++)
    {
        for(int c=r+1;c<n;c++)
            {
                if(A[r][c]>-1)
                    {
                        e[M].cost=A[r][c];
                        e[M].src=r;
                        e[M].dst=c;
                        M+=1;
                    }
            }
    }
}

bool cmp(edge e1,edge e2)
{
    return e1.cost<=e2.cost;
}
int main()
{
    int n,count=0;
    cin>>n;
    init(n);
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++){
                cin>>A[i][j];
        }
    }
    checkEdges(n);
    sort(e,e+M,cmp);
    for (int i=0; i<M; ++i)
    {
        if(is_same_set(e[i].src,e[i].dst))
        {
            continue;
        }
        unite(e[i].dst,e[i].src);
        count+=e[i].cost;
    }
    cout<<count<<endl;
    return 0;
}