#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cmath>
using namespace std;

struct UnionFind {
	vector<int> data;
	UnionFind(int size) : data(size, -1) { }
	bool unite(int x, int y) {
		x = root(x); y = root(y);
		if (x != y) {
			if (data[y] < data[x]) swap(x, y);
			data[x] += data[y]; data[y] = x;
		}
		return x != y;
	}
	bool same(int x, int y) {
		return root(x) == root(y);
	}
	int root(int x) {
		return data[x] < 0 ? x : data[x] = root(data[x]);
	}
	int size(int x) {
		return -data[root(x)];
	}
};

// ??????a, b?????????????????????cost??????????????????
struct Edge
{
	int a, b, cost;
	bool operator<(const Edge& o) const {
		return cost < o.cost;
	}
};

// ????????°??¨?????????????????¨????????????????????°??????
struct Graph
{
	int n;  // ????????°
	vector<Edge> es;  // ?????????

					  // ????????????????????§??????????°???¨?????¨??????????????????????¨??????????
					  // ??°??????????????£????????¨??????????°???¨????£?????????????????????¨??????
	int kruskal() {
		// ?????????????°??????????????????????
		sort(es.begin(), es.end());

		UnionFind uf(n);
		int min_cost = 0;

		for (int ei = 0; ei < es.size(); ei++) {
			Edge& e = es[ei];
			if (!uf.same(e.a, e.b)) {
				// ????????????????????????????????§???????????????????????????????????¨??????
				min_cost += e.cost;
				uf.unite(e.a, e.b);
			}
		}

		return min_cost;
	}
};

// ?¨??????\???????????°?????????????????????
Graph input_graph() {
	Graph g;
	int m;
	cin >> g.n >> m;
	for(int i = 0; i < m; i++){
		Edge e;
		cin >> e.a >> e.b >> e.cost;
		g.es.push_back(e);
	}
	return g;
}


int main()
{
	Graph g = input_graph();
	cout << g.kruskal() << endl;
	return 0;
}