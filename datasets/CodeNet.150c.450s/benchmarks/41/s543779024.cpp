#include <iostream>
#include <cstdio>
#include <climits>
#include <cmath>
#include <cassert>
#include <algorithm>
#include <utility>
#include <vector>
#include <string>
#include <stack>
#include <queue>
#include <map>

#define MAX 100
#define INFTY 10e12//1<<31 // 2^31
#define N 100
#define N2 10000  // N * N
#define REP(i,n) for(int i=0;i<n;i++)
#define ALL(o) (o).begin(), (o).end()

/*
priority_queue<> pq
 push()  pop() size()  top()
map<>
 find() begin() end() insert(map<>::value_type())
pair<>
sort(.begin(), .end())
sort(arr, arr+N)
sort(a, a+N, greater<int>())
binary_search(vc.begin(), vc.end(), x)  //binary_search???true, false?????????
vector<int>::iterator lit = lower_bound(vc.begin(), vc.end(), x);
  lower_bound?????????????????????"??\???"????????????????????????????????????????????¬???????????????
vector<int>::iterator uit = upper_bound(vc.begin(), vc.end(), x);
  upper_bound????????????????????????"?¶???????"?????????????????????????????????????????¬???????????????
*/


using namespace std;

typedef long long ll;

int V, E, S[500010], T[500010], D[500010];
ll C[100010];

bool bellman_ford(int r)
{
  REP(i,V)
    C[i] = INFTY;
  C[r] = 0;
  int j;
  for(j = 0; j < V; j++)
  {
    bool update = false;
    REP(i,E)
    {
      int s = S[i], t = T[i], d = D[i];
      if(C[s] < INFTY && C[s] + d < C[t])
      {
        C[t] = C[s] + d;
        update = true;
      }
    }
    if(!update) break;
  }
  return j == V;
}

int main()
{
  cin.tie(0);
  ios::sync_with_stdio(false);
  // FROM HERE
  cin >> V >> E; // V ???????????° E ????????°
  REP(i,E)
    cin >> S[i] >> T[i] >> D[i];
  REP(j,V)
  {
    if(bellman_ford(j))
    {
      cout << "NEGATIVE CYCLE" << endl;
      break;
    }
    REP(i,V)
    {
      if(C[i] == INFTY) printf("INF");
      else printf("%lld", C[i]);
      printf("%s",(i==V-1?"\n":" "));
    }
  }
  return 0;
}