#include <iostream>
#include <queue>
#include <stdlib.h>
#define INF 123456789
using namespace std;
typedef pair<int,int> P;//first:???????????¢/second:????????????
struct edge {int to,cost;};
int main() {
// AOJ0189 Dijkstra
	for (;;)
	{
		int city = 0;//?????¨???????????????????°????(0~7?????§????????????city == 8??§??????)
		int n;
		cin >> n;
		vector<edge> es[11];
		if (n == 0) break;
		for (int i = 0;i < n;i++)
		{
			int a,b,c;
			cin >> a >> b >> c;
			es[a].push_back(edge{b,c});
			es[b].push_back(edge{a,c});//????????¨???
 			city = max (max(a,b)+1,city);
		}
		int min = INF;
		int mincity;
		for (int target_city = 0;target_city < city;target_city++)
		{
			//target_city?????????????°???????????¨??????????????????????
			int d[city];
			priority_queue <P,vector<P>,greater<P> > que;
			for (int i = 0;i < city;i++)
			{
				d[i] = INF;
			}
			d[target_city] = 0;
			que.push(P(0,target_city));
			while(!que.empty())
			{
				P pp = que.top();
				que.pop();
				if(d[pp.second] < pp.first) continue;
				d[pp.second] = pp.first;
				for (int i = 0;i < es[pp.second].size();i++)
				{
					//?????????????????????????????????????????????
					if (es[pp.second][i].cost + pp.first < d[es[pp.second][i].to])
					{
						d[es[pp.second][i].to] = es[pp.second][i].cost + pp.first;
						que.push(P(d[es[pp.second][i].to],es[pp.second][i].to));
					}
				}
			}
			int sum = 0;
			for (int i = 0;i < city;i++)
			{
				sum += d[i];
			}
			if (sum < min)
			{
				min = sum;
				mincity = target_city;
			}
		}
		cout << mincity << " " << min << endl;
	}
	return 0;
}