////////////////////////////////////////
//ALDS1_12_B:   Single Source Shortest Path I
//
////////////////////////////////////////

#include <iostream>
#include <algorithm> // next_permutation
#include <iomanip>
#include <cmath>
#include <vector>
#include <sstream>
#include <string>
#include <cstdio>
#include <stack>
#include <queue>
#include <list>
#include <numeric> //accumulate
//#include <unordered_map> //hash func.
#include <fstream> //ifstream, ofstream

//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.
#include <cassert> //assert


using namespace std;

#define TEST //*******************************************************************************************************************************************
//?????????????????¨??§?????\????????????????????????????????°?????????????¨???????????????????dout???????????????????????§???????????¬??????????????????????????????????????????
//??????????????????????????????????????????????????????????§?CPU???????£??????????????????§???TLE?????????????????????????????????????????§????????¨???                           ????????????????????????cerr????????£????????????????????????????????????
#ifdef TEST
#define dout cout
#define din cin
#else
stringstream dummy; //???????????°??????dout?????????????????????????????????
#define dout dummy.str(""); dummy.clear(stringstream::goodbit); dummy //dummy?????????????????????????????????????????¨?????¢?????¢???????????????
//???????????¨??????????????????goodbit?????????????????????????????¨???????????´????????????????????????????????¨?????°?????????????????§???????????????????????????????????? http://d.hatena.ne.jp/linden/20060427/p1
#endif

//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.
//#define OUTPUTFILE "output.txt" //*******************************************************************************************************************************************
#ifdef OUTPUTFILE
#define dout outputfile //??¨????????????TLE????????§?????????dout?????¨??¨??????????????¢????????????????????????????????????????????§????¨????????????´??????????????£??????????????????????¨?????????????????????????????????????????????§?????????????????????
ofstream outputfile(OUTPUTFILE);
#define OutputFilePath "/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt"
#endif

//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.
//#define INPUTFILE "input.txt" //*******************************************************************************************************************************************
#ifdef INPUTFILE
#define din inputfile
ifstream inputfile(INPUTFILE);
#endif


#define disp(A) dout << #A << " = " << setw(3) << (A) << endl
#define disP(A) dout << setw(3) << (A) << " "
#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)
#define dispAll(A,n) dout << #A << " = "; rep(j, 0, (n)) {disP(A[j]);} dout << endl

typedef pair<int,int> pii;
typedef vector<int> vi;
typedef long long ll;


const int INF = 2e9-1;
const ll INF_LL = 1e18-999; //Be careful for overflow.

#define N_MAX 100 //num of vertex
#define M_MAX 10000 //num of edge

int N; //num of vertex
int adjacencyMatrix[N_MAX][N_MAX];
vector< vector< pii > > adjacencyList; //adjacencyList[i] = list of <adjacent vertex, cost to it from i>

ll minCostTo[N_MAX]; //min cost to i from 0. Will be updated by Daijkstra Algorithm.
vi V; //vertices which is not yet determined by Dijkstra





int main() {
    
    //read input data and initialize
    din >> N;
    
    rep(i,0,N) {
        minCostTo[i] = INF;
        V.push_back(i);
        
        rep(j,0,N) {
            adjacencyMatrix[i][j] = (i==j ? 0 : INF);
        }
    }
    
    int u, numOfAdjacentNode, v, c;
    rep(i,0,N) {
        din >> u >> numOfAdjacentNode; //u == i
        
        vector< pii > list;
        
        rep(j,0,numOfAdjacentNode) {
            din >> v >> c;
            list.push_back(make_pair(v, c));
            adjacencyMatrix[u][v] = c;
        }
        
        adjacencyList.push_back(list);

    }
    
//    //DEBUG
//    rep(i,0,N) {
//        rep(j,0,N) {
//            dout << setw(3) << adjacencyMatrix[i][j] << " ";
//        }
//        dout << endl;
//    }
//    dout << endl;
//    rep(i,0,N) {
//        disP(i); dout << " : ";
//        for(auto x : adjacencyList[i]) {
//            dout << x.first << "(" << x.second << ") ";
//        }
//        dout << endl;
//    }
//    dout << endl;
    
    
    //Dijkstra Algorithm
    u = V.front(); // u = 0
    vi::iterator itr_to_u = V.begin();
    
    minCostTo[0] = 0;
    
    while( !V.empty() ) {
        
//        //DEBUG
//        dout << "---------------\n";
//        disp(u);
//        disp(minCostTo[u]);
//        dout << endl;
        
        for(vector<pii>::iterator itr=adjacencyList[u].begin(); itr!=adjacencyList[u].end(); itr++) {
            v = itr->first;
            c = itr->second;
            
//            //DEBUG
//            dout << "---\n";
//            disp(v);
//            disp(c);
//            dout << endl;
//            disp(minCostTo[v]);
//            disp(minCostTo[u] + c);
            
            if( minCostTo[v] > minCostTo[u] + c ) {
                minCostTo[v] = minCostTo[u] + c;
//                dout << "*** Updated ***\n";
            }
            
//            dout << "new "; disp(minCostTo[v]);
//            dout << endl;
        }
        
        
        V.erase(itr_to_u); //remove u
        
//        //DEBUG
//        dout << "---\n";
//        for(vi::iterator itr=V.begin(); itr!=V.end(); itr++) {
//            disP(*itr); disp(minCostTo[*itr]);
//        }
//        dout << endl;
        
        
        
        //find next u which has min cost among V
        itr_to_u = V.begin();
        for(vi::iterator itr=V.begin(); itr!=V.end(); itr++) {
            if(minCostTo[*itr_to_u] > minCostTo[*itr]) {
                itr_to_u = itr;
            }
        }
        u = *itr_to_u;
        
//        //DEBUG
//        dout << "next u = " << u << endl;
        
    }
    
    
    //output
    rep(i,0,N) {
        dout << i << " " << minCostTo[i] << endl;
    }
    
    
    
#ifdef INPUTFILE
    inputfile.close();
#endif
    
#ifdef OUTPUTFILE
    outputfile.close();
    cout << "\"" << OutputFilePath << "\"" << endl;
#endif
    
    return 0;
}