#include <bits/stdc++.h>

using namespace std;

class D3
{
public:
	double x;
	double y;
	double z;

	//?????????????????????
	D3 ( double x_ = 0.0 , double y_ = 0.0 , double z_ = 0.0 )
	{
		x = x_;
		y = y_;
		z = z_;
	}

	//??????
	D3 Cross_product ( D3 partner )
	{
		D3 ret ( y*partner.z - z*partner.y , z*partner.x - x*partner.z , x*partner.y - y*partner.x );
		return ret;
	}

	//??????
	double Inner_product ( D3 partner )
	{
		return x*partner.x + y*partner.y + z*partner.z;
	}

	//?????????????????????????????????
	D3 Make_vector ( D3 partner )
	{
		D3 ret ( partner.x - x , partner.y - y , partner.z - z );
		return ret;
	}

	//???????§????2????????????????????¢???????±???????
	double S_vec ( D3 A , D3 B )
	{
		D3 G;
		G = A.Cross_product ( B );
		return sqrt ( G.Inner_product ( G ) ) / 2;
	}

	//??????????????¢???????±???????
	double S_point ( D3 A , D3 B , D3 C )
	{
		return S_vec ( A.Make_vector ( B ) , A.Make_vector ( C ) );
	}

	//???????§????3????????????????????????????±???????
	double V_vec ( D3 A , D3 B , D3 C )
	{
		D3 G;
		G = A.Cross_product ( B );
		return G.Inner_product ( C ) / 6;
	}

	//4???????????????????±???????
	double V_point ( D3 A , D3 B , D3 C , D3 D )
	{
		return V_vec ( A.Make_vector ( B ) , A.Make_vector ( C ) , A.Make_vector ( D ) );
	}

	D3 operator+( D3 partner )
	{
		return D3 ( x + partner.x , y + partner.y , z + partner.z );
	}

	D3 operator-( D3 partner )
	{
		return D3 ( x - partner.x , y - partner.y , z - partner.z );
	}

	D3 operator*( D3 partner )
	{
		return D3 ( x * partner.x , y * partner.y , z * partner.z );
	}

	D3 operator/( D3 partner )
	{
		return D3 ( x / partner.x , y / partner.y , z / partner.z );
	}

	D3 operator*( double d )
	{
		return D3 ( x * d , y * d , z * d );
	}

	D3 operator/( double d )
	{
		return D3 ( x / d , y / d , z / d );
	}

	bool operator==( D3 partner )
	{
		return x == partner.x&&y == partner.y&&z == partner.z;
	}

	double length ()
	{
		return sqrt ( x*x + y*y + z*z );
	}

	//???????????????????????????
	//????????¨???
	D3 Unit_vec ()
	{
		return D3 ( *this ) / ( *this ).length ();
	}

	//????????????????????????
	D3 Inverse_vec ()
	{
		return D3 ( *this )*-1;
	}

	//?????´????????????
	bool Vertical ( D3 partner )
	{
		return ( *this ).Inner_product ( partner ) == 0;
	}

	//??????????????????
	bool Parallel ( D3 partner )
	{
		return ( *this ).Unit_vec () == partner.Unit_vec () || ( *this ).Unit_vec ().Inverse_vec () == partner.Unit_vec ();
	}

};

int main ()
{
	double x1 , y1 , x2 , y2 , x3 , y3 , xp , yp;
	while( cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> xp >> yp )
	{
		D3 X ( x1 , y1 ) , Y ( x2 , y2 ) , Z ( x3 , y3 ) , P ( xp , yp ) , calc;
		if( abs ( calc.S_point ( X , Y , Z ) - ( calc.S_point ( X , Y , P ) + calc.S_point ( X , Z , P ) + calc.S_point ( Z , Y , P ) ) ) < 1e-6 )
		{
			cout << "YES" << endl;
		} else
		{
			cout << "NO" << endl;
		}
	}
}