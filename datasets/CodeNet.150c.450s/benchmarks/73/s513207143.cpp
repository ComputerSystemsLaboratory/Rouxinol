#include "bits/stdc++.h"
using namespace std;

//?????????
#pragma region MACRO 
#define putans(x)  std::cerr << "[ answer ]: " ; cout << (x) << endl
#define dputans(x) std::cerr << "[ answer ]: "; cout << setprecision(40) << (double)(x) << endl
#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)
#define RREP(i,n,a) for(int i=(int)(n-1); i>= a; i--)
#define rep(i,n) REP(i,0,n)
#define rrep(i,n) RREP(i,n,0)
#define all(a) begin((a)),end((a))
#define mp make_pair
#define exist(container, n) ((container).find((n)) != (container).end())
#define equals(a,b) (fabs((a)-(b)) < EPS)
#ifdef _DEBUG //???????????????????????????????????????????????????
std::ifstream ifs("data.txt");
#define put ifs >>
#else //?????£????????????????????§?????????????????????
#define put cin >>
#endif
#pragma endregion
//???????????°??????????????´
#pragma region CODING_SUPPORT
#ifdef _DEBUG
#define dbg(var0) { std::cerr << ( #var0 ) << "=" << ( var0 ) << endl; }
#define dbg2(var0, var1) { std::cerr << ( #var0 ) << "=" << ( var0 ) << ", "; dbg(var1); }
#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << "=" << ( var0 ) << ", "; dbg2(var1, var2); }
#define dbgArray(a,n) {std::cerr << (#a) << "=";  rep(i,n){std::cerr <<(a[i])<<",";} cerr<<endl;} 
#else
#define dbg(var0) {}
#define dbg2(var0, var1) {}
#define dbg3(var0, var1, var2) {}
#define dbgArray(a,n) {}
#endif 
#pragma endregion 
//typedef????????????????????????????¶????????????§?????????
#pragma region TYPE_DEF
typedef long long ll;
typedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;
typedef pair<long long, long long> pll;
typedef vector<int> vi;
#pragma endregion
//??????????????°(???????????????????????§??????)
#pragma region CONST_VAL
#define PI (2*acos(0.0))
#define EPS (1e-10)
#define MOD (ll)(1e9 + 7)
#define INF (ll)(2*1e9)
#pragma endregion

//?????????????????????????????????????±?????????????????????°???????????¨
	//int double ??¨??????numeric???????????£?????????????????????
	//n ????´???°
	//invalid_value ???????????°???????????????a????????????marge(a,invalidvalue) = a, marge(invalid_value, a) = a?????¨??????????????????
	class SegmentTreeLL {
	public:
		SegmentTreeLL(int n, ll invalid_value);
		~SegmentTreeLL();
		void SetElem(int k, ll val);
		int GetCount();
		ll quary(int a, int b);
		ll GetElem(int k);

		//?????????????????¢??°???????????????????????????
		//invalid_value??????????????£?????°????????????????????????
		bool IsInvalidValue (ll value) {
			return value == mInvalidValue;
		}
		//a??¨b?????? a???b????±?????????¢??°???????????§?¨?????????????????????§?±???????
		ll Marge(ll a, ll b) {
			return a+b; //??????????°?
		}
	private:
		vector<ll>
			mTree;
		int mCount;
		ll mInvalidValue;
		void Update(int k, ll val);
		ll InternalQuary(int a, int b, int k, int l, int r);
	};

	
	SegmentTreeLL::SegmentTreeLL(int n, ll invalid_value) {
		int bin_n = 1;
		while (bin_n < n) bin_n *= 2;
		mTree.resize(2 * bin_n);
		mInvalidValue = invalid_value;
		mCount = bin_n;
		for (int i = 0; i < 2 * bin_n - 1; i++) {
			mTree[i] = invalid_value;
		}
	}
	SegmentTreeLL::~SegmentTreeLL() {
	}
	void SegmentTreeLL::SetElem(int k, ll val) {Update(k, val);}
	ll SegmentTreeLL::GetElem(int k) {return mTree[mCount - 1 + k];}
	int SegmentTreeLL::GetCount() {return mCount;}
	//????????´??°
	void SegmentTreeLL::Update(int k, ll val) {
		k += mCount - 1;
		mTree[k] = val;
		while (k > 0) {
			k = ( k - 1 ) / 2;
			mTree[k] = Marge(mTree[2 * k + 1], mTree[2 * k + 2]);
		}
	}

	//??????[a,b]?????????O(ln(Count))??§?±??????? b < GetCount??¨???????????¨
	//ex. a = 0 , b = 2 ?????? 0,1,2?????????
	ll SegmentTreeLL::quary(int a, int b) {
		return InternalQuary(a, b + 1, 0, 0, mCount);
	}
	//?????¨?????????
	ll SegmentTreeLL::InternalQuary(int a, int b, int k, int l, int r) {
		if (r <= a || b <= l)return mInvalidValue;
		if (a <= l && r <= b)return mTree[k];
		else {
			int vl = InternalQuary(a, b, k * 2 + 1, l, ( l + r ) / 2);
			int vr = InternalQuary(a, b, k * 2 + 2, ( l + r ) / 2, r);
			return Marge(vl, vr);
		}
	}


const static int MAX_V = 10000;

vector<int> G[MAX_V];
int root;

int vs[MAX_V * 2 - 1];
int depth[MAX_V * 2 - 1];
int id[MAX_V];

void dfs(int v, int p , int d, int &k) {
	id[v] = k;
	vs[k] = v;
	depth[k++] = d;
	rep(i, G[v].size()) {
		if (G[v][i] != p) {
			dfs(G[v][i],v,d+1,k);
			vs[k] = v;
			depth[k++] = d;
		}
	}
}
//
//void init(int V) {
//	int k = 0;
//	dfs(root,-1,0,k);
//	rmq_init(depth, V * 2 -1);
//}
//
//int lca(int u, int v) {
//	return vs[quary(min(id[u],id[v])),max(id[u],id[v])+1];
//}

int main() {
	int n, q;
	put n >> q;
	SegmentTreeLL segll(n+1, 0);
	rep(i, q) {
		int com, x, y; put com >> x >> y;
		if (com == 0) {
			segll.SetElem(x,y+segll.GetElem(x));
		}
		else {
			cout << segll.quary(x,y) << endl;
		}
	}
END:

	return 0;
}