/**
 * @brief  額面がc1, c2, ..., cm円のm種類のコインを使って、n円払うときのコインの最小の枚数を求める
 *         各額面のコインは何度でも使用することができる
 *
 * @note   仮にコインの額面が日本円のように1, 5, 10, 50, 100, 500と決められていれば、与えられた額n円に対して、
 *         額面の大きいものから引いて(割って)いけば、最小の枚数を求めることができる
 *         このように、その時点で最適の解(方法)を選んでいくアルゴリズムを貪欲法(greedy method)という
 *
 * @note   一方、一般的なコイン問題は、使用できる額面によっては貪欲法では正しく解を求めることができない
 *         たとえば、額面が1, 2, 7, 8, 12, 50のについて、15円を支払いたい場合、上記の貪欲法では
 *         12, 2, 1の3枚を選んでしまうが、最適な解は8, 7の2枚となる
 *
 * @note   この問題は動的計画法で最適解を求めることができる. まず、以下のような変数を用意する
 *
 *           C[m]       C[i]をi番目のコインの額面とする配列
 *           T[m][n+1]  T[i][j]をi番目までのコインを使ってj円支払うときのコインの最小枚数とする2次元配列
 *
 *         コインの枚数i, 各iにおける支払う金額jを増やしていき、T[i][j]を更新していく
 *         T[i][j]は、i番目のコインを使わない場合と使う場合の枚数を比べ、小さい方を選べばよいので、
 *         次の漸化式で求めることができる
 *
 *           T[i][j] = min(T[i - 1][j], T[i][j - C[i]] + 1)
 *
 *         i枚目のコインを使わない場合は、ここまで計算したj円を払う最適解T[i-1][j]となり、
 *         使った場合は、現在の金額jからC[i]を引いた金額を払う最適解に1枚足した値となる
 *         たとえば、3枚目のコイン(額面8)までを使って15円払う最適解は、min(T[2][15], T[3][15 - 8] + 1)より、
 *         2枚となる. これは3枚目のコインまでを使って7円払う最適解に1(枚)足したものである
 *
 * @note   コインの額面ごとに最適枚数を記録しておく必要はないので、j円払うときのコインの最小枚数は1次元配列の
 *         要素T[j]として、次のように求められる
 *
 *           T[j] = min(T[j], T[j - C[i]] + 1)
 *
 * @date   2016/05/04
 */



//********************************************************************************
// 必要なヘッダファイルのインクルード
//********************************************************************************

#include <iostream>
#include <vector>



//********************************************************************************
// 型シノニム
//********************************************************************************

using value_t = std::size_t;

using values_t = std::vector<value_t>;
using dptbl_t  = std::vector<std::size_t>;



//********************************************************************************
// 大域変数の定義
//********************************************************************************

static const std::size_t INFINITY  = (1 << 29);



//********************************************************************************
// 関数の定義
//********************************************************************************

/**
 * @brief  動的計画法によってコイン問題を解きます
 *
 * @param  const values_t& C  C[i]をi番目のコインの額面とする配列
 * @param  value_t         n  支払う金額n円
 * @return コインの最小枚数
 */
std::size_t coin_changing(const values_t& C, value_t n)
{
    dptbl_t T(n + 1, INFINITY); T[0] = 0;  // T[0..n+1]を新しい配列とする(ここでT[i]はi円払うコインの最小枚数)
    
    for (std::size_t i = 0, m = C.size(); i < m; i++) {
        for (value_t j = C[i]; j <= n; j++) {
            T[j] = std::min(T[j], T[j - C[i]] + 1);
        }
    }
    return T[n];
}



//********************************************************************************
// エントリポイント
//********************************************************************************

int main()
{
    using namespace std;
    
    int n, m;

    cin >> n >> m;
    
    values_t C(m);
    for (int i = 0; i < m; i++) { cin >> C[i]; }

    cout << coin_changing(C, n) << endl;

    return 0;
}