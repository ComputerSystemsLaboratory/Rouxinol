#include <iostream>
#include <queue>
#include <vector>
#include <climits>
using namespace std;

#define MAX_E 2001
#define MAX_V 1001
#define INF INT_MAX

typedef struct edge{
    int from;
    int to;
    int cost;
}edge;

edge es[MAX_E];
int cost[MAX_V];

/*
 * negative?????????????????¨????????´?????????-1?????????
 * n:?????????????????°
 * s:????§??????????
 * e:??¨??????????????°
 */
int BellmanFord(int n, int s, int e) {
    //j???negative loop??????????????????????????¨????????????
    int j = 0, update;
    
    //????§?????????????????????????0???????????????????????????????????§
    fill(cost, cost + MAX_V, INF);
    cost[s] = 0;
    
    while (1) {
        update = 0;
        for (int i = 0; i < e; i++) {
            edge e = es[i];
            if
            (
                cost[e.from] != INF
                &&
                cost[e.to] > cost[e.from] + e.cost
            )
            {
                cost[e.to] = cost[e.from] + e.cost;
                update = 1;
            }
        }
        
        // update?????´??°???????????´????????????????????\???cost????????´??°???????????????????????????????????????
        if (!update) return 1;
        
        /*
         * j???n????¶?????????´??????n????????????????????\??????cost?????´??°???????????´????????????
         * negative loop????????¨??????
         */
        if (j > n) return -1;
        j++;
    }
    return 1;
}

int main( ){
    
    int i, V, E, r, u, v, c, rtn;
    edge tmp;
    cin >> V >> E >> r;

    for (i = 0; i < E; i++) {
        cin >> u >> v >> c;
        tmp.cost = c;
        tmp.to = v;
        tmp.from = u;
        es[i] = tmp;
    }
    
    rtn = BellmanFord(V, r, E);
    
    if (rtn == -1){
        cout << "NEGATIVE CYCLE" << endl;
        return 0 ;
    }
    
    for (i=0; i<V; i++) {
        if (cost[i] == INF) {
            cout << "INF" << endl;
        }else{
            cout << cost[i] << endl;
        }
    }
    
    return 0;
}