/**
 * Areas on the Cross-Section Diagram
??°??????????°´????????¨??????????´??°´????¢??????¶??????????????\??¬????????§?????§????????????????????????

??????????????? 1??1(m2)
???????????????????????????????????¨???????????°???????¨?????????¢??????????????????????????§?????°????????§??????????°´??????????????¢????????±????????????????????????



?????????????????°?????????????????????????????¨??????????????°???????????¢??????????°´????????????????????????????????¨??????????????????
????????°??????????????¢?????§?????????????????¢?????? 4???2???1???19???9 ????°´??????????????§????????????

??\???
?¨?????????¢????????????????????¢??? '/' ??¨ '\'????????°??? '_'
??§??¨????????????????????????????????????????????????????????°??????????¨?????????¢???????????????
\\///\_/\/\\\\/_/\\///__\\\_\\/_\/_/\ ??§?????????????????????

??????
?¬??????¢?????§?°´??????????????¢?????????????????????????????????

A
k L1 L2 ... Lk

??????????????°????????§???????°´?????????????????¢????????¨?????´??° A ??????????????????????????????

?????????????°´??????????????° k???????°´??????????????¢??? Li(i=1,2,...,k)
????????¢?????????????????????????????????????????§???????????????????????????

??¶?´?
1????????????????????????20,000
????????????????????? 50 ???????????\???????????¶???????????????

?°´??????????????°???????????\?????§?????? (k???1)?????????????????????????????? 100 ??\?????§?????????
??\?????? 1
\\//
????????? 1
4
1 4

??\?????? 2
\\///\_/\/\\\\/_/\\///__\\\_\\/_\/_/\
????????? 2
35
5 4 2 1 19 9
 */

#include <iostream>
#include <numeric>
#include <sstream>
#include <stack>
#include <vector>
#include <tuple>

int main(int argc, char const *argv[]) {
  std::string Topography = R"X(\\///\_/\/\\\\/_/\\///__\\\_\\/_\/_/\)X";
  std::stack<unsigned int> Conf;
  std::stack<std::tuple<unsigned int, unsigned int>> Pool;
  getline(std::cin, Topography);
  unsigned int ConfigurationCount = Topography.size();
  unsigned int StartConf = 0;
  unsigned int area = 0;
  for (size_t i = 0; i < ConfigurationCount; i++) {
    switch (Topography[i]) {
    case '\\':
      Conf.push(i);
      break;
    case '/':
      if (!Conf.empty()) {
        StartConf = Conf.top();
        Conf.pop();
        area = i - StartConf;
        if (Pool.empty()) {
          Pool.push(std::make_tuple(StartConf, area));
        } else {
          unsigned int PrevConf, PrevArea;
          std::tuple<unsigned int, unsigned int> t;
          t = Pool.top();
          PrevConf = std::get<0>(t);
          PrevArea = std::get<1>(t);
          if (StartConf > PrevConf) {
            Pool.push(std::make_tuple(StartConf, area));
            break;
          } else {
            while (!Pool.empty()) {
              PrevConf = std::get<0>(Pool.top());
              PrevArea = std::get<1>(Pool.top());
              if (PrevConf > StartConf) {
                /* code */
                Pool.pop();
                area += PrevArea;
              } else {
                break;
              }
            }
            Pool.push(std::make_tuple(StartConf, area));
          }
        }
      }
      break;
    case '-':
      break;
    }
  }

  std::vector<unsigned int> Areas;
  while (!Pool.empty()) {
    Areas.insert(Areas.begin(), std::get<1>(Pool.top()));
    Pool.pop();
  }

  std::cout << std::accumulate(Areas.begin(), Areas.end(), 0) << std::endl;
  unsigned int PoolCount = Areas.size();
  std::cout << PoolCount;
  for (const auto &e : Areas) {
    std::cout << " " << e;
  }
  std::cout << std::endl;
  return 0;
}